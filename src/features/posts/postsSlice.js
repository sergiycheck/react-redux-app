
import {
	createSlice, 
	nanoid,
	createAsyncThunk, 
	createSelector,
	createEntityAdapter	 
} from '@reduxjs/toolkit';

import {sub} from 'date-fns'; 
import { client } from '../../api/client';

import 
{
	postsRoute,
	postsName,
	StatusData,
	getAllPostsPrefix,
	addPostPrefix} from '../ApiRoutes';

// const postsData = [
// 	{
// 		id:nanoid(),
// 		date:sub(new Date(),{minutes:62}).toISOString(),
// 		reactions: {
//       thumbsUp: 0,
//       hooray: 0,
//       heart: 0,
//       rocket: 0,
//       eyes: 0,
//     },
// 		title:'first title',content:'first content'
// 	},
// 	{
// 		id:nanoid(),
// 		date:sub(new Date(),{minutes:17}).toISOString(),
// 		reactions: {
//       thumbsUp: 0,
//       hooray: 0,
//       heart: 0,
//       rocket: 0,
//       eyes: 0,
//     },
// 		title:'second title',content:'second content'
// 	},
// ]


//sorts our posts
const postsAdapter = createEntityAdapter({
	sortComparer:(a,b)=>b.date.localeCompare(a.date)
})

// getInitialState returns an empty {ids:[], entities:{}} normalized state object
const initialState = postsAdapter.getInitialState({
	//
	status:StatusData.idle,
	error:null
})


//redux toolkit's createAsyncThunk API generates thunks
//that automaticaly dispatches those start/success/failure actions

export const fetchPosts = createAsyncThunk(
		getAllPostsPrefix, 
		async () => {
			const response = await client.get(postsRoute);
			console.log('got response',response);
			return response.posts;
})

//initialPost { title, content, user: userId }
export const addNewPost = createAsyncThunk(
	addPostPrefix,
	async(initialPost)=>{
		const response  = await client.post(postsRoute,{post:initialPost});
		console.log('got response', response);
		//Response includes the complete post obj with ID
		return response.post;
})

//posts are being kept in a lookup table state.entities
const postsSlice = createSlice({
	name:'posts', // array of postItems
	initialState,


	reducers:{

		/*
    postAdded: {

      reducer(state, action) {
        state.postItems.push(action.payload)
      },

      prepare(title, content,userId) {
        return {
          payload: {
            id: nanoid(),
            title,
						date:new Date().toISOString(),
            content,
						reactions: {
              thumbsUp: 0,
              hooray: 0,
              heart: 0,
              rocket: 0,
              eyes: 0,
            },
						userId:userId
          }
        }
      }
    },*/

		//createSlice lets us write "mutating" logic in our reducers.
		reactionAdded(state,action){
			const {postId,reaction} = action.payload;
			//
			const existingPost = state.entities[postId];

			if(existingPost){
				existingPost.reactions[reaction]++;
			}
		},

		postDeleted(state,action){
			const {postId} = action.payload;
			//
			const existingPost = state.entities[postId]
			if(existingPost){
				state.postItems.pop(existingPost);
			}
		},
		postUpdated(state,action){
			const {id,title,content} = action.payload;
			//
			const existingPost = state.entities[id]
			if(existingPost){
				existingPost.title = title;
				existingPost.content = content;
			}
		}
	},

//The keys in the extraReducers object should be Redux action type strings, like 'counter/increment'
	//However, action creators generated by Redux Toolkit 
	//automatically return their action type string 
	//if you call actionCreator.toString(). 
	//This means we can pass them as ES6 ! object literal 
	//computed properties! , and the action 
	//types will become the keys of the object:
	extraReducers:{
		[fetchPosts.pending]:(state,action)=>{
			state.status = StatusData.loading;
		},
		[fetchPosts.fulfilled]:(state,action)=>{
			state.status = StatusData.succeeded;
			// state.postItems = state.postItems.concat(action.payload)

			//Use the `upsertMany` reducer as a mutating update utility
			//upsertMany merges action.payload posts on id if the same posts
			// already existing in state
			postsAdapter.upsertMany(state,action.payload);
		},
		[fetchPosts.rejected]:(state,action)=>{
			state.status = StatusData.failed;
			state.error = action.error.message;
		},

		[addNewPost.fulfilled]:(state,action)=>{
			// state.postItems.push(action.payload);
			postsAdapter.addOne(action.payload);
		}
	}

})
export const {
	postAdded,
	postUpdated,
	reactionAdded,
	postDeleted} = postsSlice.actions;

export default postsSlice.reducer;

//Note that the state parameter for these selector 
//functions is the root Redux state object

// export const selectAllPosts = (state) => state.posts.postItems;
// export const selectPostById = (state,postId)=>
// 	state.posts.postItems.find(post=>post.id===postId);



//Export the customized selectors for this adapter 
//using `getSelectors`
export const {
	
	selectAll:selectAllPosts,
	selectById: selectPostById,
	selectIds: selectPostIds

	//high order function ?
	//Pass in a selector that returns the posts slice of state
	//pass state.posts in order to find posts in Redux state
} = postsAdapter.getSelectors(state=>state.posts)



	// createSelector takes one input selector func
	// plus an output selector func
	// first input selector returns userId
	// second output selector return filtered array of posts
	//if we call selectPostsByUserMultiple times with
	//the same state, and userId it will only re-run
	//output selector  
export const selectPostsByUser = createSelector(
	[selectAllPosts,(state,userId)=>{
		console.log('calling selectAllPosts input selector. UserId: ',userId);
		return userId
	}],
	(posts,userId)=>{
		console.log('second output selector. UserId: ', userId)
		return posts.filter(post=>post.user == userId)
	}
)



//YOu can write reusable 'selector' function to encapsulate reading values from Redux state
	//selectors are funcs that get Redux state as arg and return some data
//Redux uses plugin called 'middleware' to enable async logic
	// redux-thunk is a standard async middleware and included in redux toolkit
	// thunk func receive dispatch and getState as args, and use those for async logic
// You can dispatch actions to track the loading status of api calls
	//the pattern is dispatching 
	//pending before the call -> success with data -> failure with error 
	//loading state is usually enum with idle, loading, succeeded, failed
// Redux Toolkit has a createAsyncThunk, that dispatches these actions for you
	// - CreateAsyncThunk accepts a payload creator that should return a Promise, and 
	//   generate pending/fulfilled/rejected actions automaticaly
	// - Generated action like fetchPosts or addNewPost dispatches those actions 
	//   base on the Promise you return
	// - Actions are listened in createSlice object using the extraReducers field 
	//   and update the state base on those actions
	// - Action creators can be use to automatically fill in the keys of extraReducers obj so the 
	//   slice knows what action to listen for


