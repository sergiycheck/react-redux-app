
import {
	createSlice, 
	nanoid,
	createAsyncThunk } from '@reduxjs/toolkit';
import {sub} from 'date-fns'; 
import { client } from '../../api/client';

import {postsRoute,postsName,StatusData} from '../ApiRoutes';

// const postsData = [
// 	{
// 		id:nanoid(),
// 		date:sub(new Date(),{minutes:62}).toISOString(),
// 		reactions: {
//       thumbsUp: 0,
//       hooray: 0,
//       heart: 0,
//       rocket: 0,
//       eyes: 0,
//     },
// 		title:'first title',content:'first content'
// 	},
// 	{
// 		id:nanoid(),
// 		date:sub(new Date(),{minutes:17}).toISOString(),
// 		reactions: {
//       thumbsUp: 0,
//       hooray: 0,
//       heart: 0,
//       rocket: 0,
//       eyes: 0,
//     },
// 		title:'second title',content:'second content'
// 	},
// ]



const initialState = {
	postItems:[],
	status:StatusData.idle,
	error:null
}
export const fetchPosts = 
	createAsyncThunk(`${postsName}/fetchPosts`,async()=>{
		const response = await client.get(postsRoute);
		console.log('got response',response);
		return response.posts;
})

const postsSlice = createSlice({
	name:'posts', // array of postItems
	initialState,


	reducers:{

    postAdded: {

      reducer(state, action) {
        state.postItems.push(action.payload)
      },
      prepare(title, content,userId) {
        return {
          payload: {
            id: nanoid(),
            title,
						date:new Date().toISOString(),
            content,
						reactions: {
              thumbsUp: 0,
              hooray: 0,
              heart: 0,
              rocket: 0,
              eyes: 0,
            },
						userId:userId
          }
        }
      }
    },

		//createSlice lets us write "mutating" logic in our reducers.
		reactionAdded(state,action){
			const {postId,reaction} = action.payload;
			const existingPost = state.postItems.find(post=>post.id===postId);
			if(existingPost){
				existingPost.reactions[reaction]++;
			}
		},

		postDeleted(state,action){
			const {postId} = action.payload;
			const existingPost = state.postItems.find(post=>post.id===postId);
			if(existingPost){
				state.postItems.pop(existingPost);
			}
		},
		postUpdated(state,action){
			const {id,title,content} = action.payload;
			const existingPost = state.postItems.find(post=>post.id===id);
			if(existingPost){
				existingPost.title = title;
				existingPost.content = content;
			}
		}
	},


	//However, action creators generated by Redux Toolkit 
	//automatically return their action type string 
	//if you call actionCreator.toString(). 
	//This means we can pass them as ES6 object literal 
	//computed properties, and the action 
	//types will become the keys of the object:
	extraReducers:{
		[fetchPosts.pending]:(state,action)=>{
			state.status = StatusData.loading;
		},
		[fetchPosts.fulfilled]:(state,action)=>{
			state.status = StatusData.succeeded;
			state.postItems = state.postItems.concat(action.payload)
		},
		[fetchPosts.rejected]:(state,action)=>{
			state.status = StatusData.failed;
			state.error = action.error.message;
		}
	}

})
export const {
	postAdded,
	postUpdated,
	reactionAdded,
	postDeleted} = postsSlice.actions;

export default postsSlice.reducer;

//Note that the state parameter for these selector 
//functions is the root Redux state object

export const selectAllPosts = (state) => state.posts.postItems;
export const selectPostById = (state,postId)=>
	state.posts.postItems.find(post=>post.id===postId);